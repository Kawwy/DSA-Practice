# Progress Tracker
### Daily practice for data structures

 - [x] Complete Git & GitHub Course
 - [x] Introduction to Programming
     - [x] Types of languages
     - [x] Memory management
 - [x] Flow of the program
     - [x] Flowcharts
     - [x] Pseudocode
 - [x] Introduction to Java
     - [x] Introduction
     - [x] How it works
     - [x] Setup Installation
     - [x] Input and Output in Java
     - [x] Conditionals & Loops in Java
     - [x] if else
     - [x] loops
     - [x] Switch statements
     - [x] Data types
     - [x] Coding best practices
 - [x] Functions
     - [x] Introduction
     - [x] Scoping in Java
     - [x] Shadowing
     - [x] Variable Length Arguments
     - [x] Overloading
 - [ ] Arrays
     - [x] Introduction
     - [x] Memory management
     - [x] Input and Output
     - [x] ArrayList Introduction
     - [ ] Sorting
         - [ ] Insertion Sort
         - [ ] Selection Sort
         - [ ] Bubble Sort
         - [ ] Cyclic Sort (Merge sort etc after recursion)
     - [ ] Searching
         - [x] Linear Search
         - [x] Binary Search
         - [ ] Modified Binary Search
         - [ ] Binary Search Interview questions
         - [ ] Binary Search on 2D Arrays
 - [x] Pattern questions
 - [x] Strings
     - [x] Introduction
     - [x] How Strings work
     - [x] Comparison of methods
     - [x] Operations in Strings
     - [x] StringBuilder in java
 - [ ] Maths for DSA
     - [ ] Introduction
     - [ ] Complete Bitwise Operators
     - [ ] Prime numbers
     - [ ] HCF / LCM
     - [ ] Sieve of Eratosthenes
     - [ ] Newton's Square Root Method
     - [ ] Number Theory
     - [ ] Euclidean algorithm
 - [ ] Space and Time Complexity Analysis
     - [ ] Introduction
     - [ ] Comparion of various cases
     - [ ] Solving Linear Recurrence Relations
     - [ ] Solving Divide and Conquer Recurrence Relations
     - [ ] Big-O, Big-Omega, Big-Theta Notations
     - [ ] Get equation of any relation easily - best and easiest approach
     - [ ] Complexity discussion of all the problems we do
     - [ ] Space Complexity
     - [ ] Memory Allocation of various languages
     - [ ] NP Completeness and Hardness
 - [ ] Recursion
     - [ ] Introduction
     - [ ] Why recursion?
     - [ ] Flow of recursive programs - stacks
     - [ ] Convert recursion to iteration
     - [ ] Tree building of function calls
     - [ ] Tail recursion
     - [ ] - Sorting:
         - [ ] Merge Sort
         - [ ] Quick Sort
     - [ ] Backtracking
         - [ ] Sudoku Solver
         - [ ] N-Queens
         - [ ] N-Knights
         - [ ] Maze problems
     - [ ] Recursion String Problems
     - [ ] Recursion Array Problems
     - [ ] Recursion Pattern Problems
     - [ ] Subset Questions
     - [ ] Recursion - Permutations, Dice Throws etc Questions
 - [x] Object Oriented Programming
     - [x] Introduction
     - [x] Classes & its instances
     - [x] this keyword in Java
     - [x] Properties
         - [x] Inheritance
         - [x] Abstraction
         - [x] Polymorphism
         - [x] Encapsulation
     - [x] Overloading & Overriding
     - [x] Static & Non-Static
     - [x] Access Control
     - [x] Interfaces
     - [x] Abstract Classes
     - [x] Singleton Class
     - [x] final, finalize, finally
     - [x] Exception Handling
 - [x] Linked List
     - [x] Introduction
     - [x] Singly and Doubly Linked List
     - [x] Circular Linked List
     - [x] Fast and slow pointer
     - [x] Cycle Detection
     - [x] Reversing of LinekdList
     - [x] Linked List Interview questions
 - [ ] Stacks & Queues
     - [ ] Introduction
     - [ ] Interview problems
     - [ ] Push efficient
     - [ ] Pop efficient
     - [ ] Queue using Stack and Vice versa
     - [ ] Circular Queue
 - [ ] Dynamic Programming
     - [ ] Introduction
     - [ ] Recursion + Recursion DP + Iteration + Iteration Space Optimized
     - [ ] Complexity Analysis
     - [ ] 0/1 Knapsack
     - [ ] Subset Questions
     - [ ] Unbounded Knapsack
     - [ ] Subseq questions
     - [ ] String DP
 - [ ] Trees
     - [ ] Introduction
     - [ ] Binary Trees
     - [ ] Binary Search Trees
     - [ ] DFS
     - [ ] BFS
     - [ ] AVL Trees
     - [ ] Segment Tree
     - [ ] Fenwick Tree / Binary Indexed Tree
 - [ ] Heaps
     - [ ] Introduction
     - [ ] Theory
     - [ ] Priority Queue
     - [ ] Two Heaps Method
     - [ ] k-way merge
     - [ ] top k elements
     - [ ] interval problems
 - [ ] Hashmaps
     - [ ] Introduction
     - [ ] Theory - how it works
     - [ ] Comparisons of various forms
     - [ ] Limitations and how to solve
     - [ ] Map using LinkedList
     - [ ] Map using Hash
     - [ ] Chaining
     - [ ] Probing
     - [ ] Huffman-Encoder
 - [ ] Tries
 - [ ] Graphs
 - - [ ] Introduction
 - - [ ] BFS
 - - [ ] DFS
 - - [ ] Working with graph components
 - - [ ] Minimum Spanning Trees
 - - [ ] Kruskal Algorithm
 - - [ ] Prims Algorithm
 - - [ ] Dijkstra’s shortest path algorithm
 - - [ ] Topological Sort
 - - [ ] Bellman ford
 - - [ ] A* pathfinding Algorithm
 - - [ ] Greedy Algorithms
 
 > ### **Advanced concepts apart from interviews**
 
 - [ ] Fast IO
 - [ ] File handling
 - [ ] Bitwise + DP
 - [ ] Extended Euclidean algorithm
 - [ ] Modulo Multiplicative Inverse
 - [ ] Linear Diophantine Equations
 - [ ] Matrix Exponentiation
 - [ ] Mathematical Expectation
 - [ ] Catalan Numbers
 - [ ] Fermat’s Theorem
 - [ ] Wilson's Theorem
 - [ ] Euler's Theorem
 - [ ] Lucas Theorem
 - [ ] Chinese Remainder Theorem
 - [ ] Euler Totient
 - [ ] NP-Completeness
 - [ ] Multithreading
 - [ ] Fenwick Tree / Binary Indexed Tree
 - [ ] Square Root Decomposition
